%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  New template code for TAMU Theses and Dissertations starting Fall 2012.  
%  For more info about this template or the 
%  TAMU LaTeX User's Group, see http://www.howdy.me/.
%
%  Author: Wendy Lynn Turner 
%	 Version 1.0 
%  Last updated 8/5/2012
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           SECTION I
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\pagestyle{plain} % No headers, just page numbers
\pagenumbering{arabic} % Arabic numerals
\setcounter{page}{1}


\chapter{\uppercase {Introduction}}

%\alexn{You can start here by following the lines of the abstract - before you proceed to describe the conventional architectures. (1) Network attached storage is important (2) The current solutions are efficient, but there is an opportunity to make them more flexible as well as achieve further improvements through coding at switches (3) We propose a new SND based solution (4) we develop a prototype as well as validate the solution through simulation.}
Network Attached Storage (NAS) is increasingly important, given the magnitude of data being generated in applications by users on an everyday basis. The current solutions are efficient, but lack in flexibility. Also, more efficient utilization of the network resources can be done by pushing additional functionality to the switches. We propose a new SDN-based solution, referred to as StorageFlow, to address these issues and quantify the gains achieved by such a design.

%new addition
\section{Conventional Storage Architecture}
\indent 
%was in Motivation section originally and started it
%Cloud storage necessitates use of storage networks, which employ their own file systems and hardware to keep data. The architectures use various optimizations, including striping and coding to ensure maximum efficiency of utilization as well as reliable storage and recovery. With increase in popularity of such services, the workload on these networks will increase.
%end of original para in motivation section
Conventional storage network architectures consist of separate devices for network and storage functionalities and span the entire range from simple RAID disks to data centers. There are two main types of storage architectures, namely, Storage Area Networks (SAN) and Network Attached Storage (NAS). SANs provide OS block-level access to data. SANs utilize protocols such as iSCSI (Internet Small Computer System Interface), Fiber Channel and Infiniband. In contrast, NAS provides OS file-level access to data through an  application layer protocol. NAS is entirely software-based and include protocols such as NFS (Network File System), FTP (File Transfer Protocol), etc.% An example of NAS is shown in Figure \ref{fig:nas}. 
 %\alex{A typical SAN network} is shown in Figure \ref{fig:san}.

Distributed storage systems ensure reliability by introducing redundancy in the system, through techniques such as mirroring and coding. With mirroring techniques, the data is replicated across several disks. Coding techniques allow us to maintain reliability while using less storage. Such techniques avoid replication of data, instead the redundancy is maintained by storing parity (encoded) data. One of the fundamental problems in NAS systems is recovery from failures: if a node storing encoded information fails, in order to maintain the same level of reliability we need to rebuild parity at a new node. Erasure codes can be used to address specific requirements to maintain efficient resource utilization, while providing reliability \cite{dimakis2011survey}. Lately, to further improve resource utilization, the network coding techniques, such as regenerative coding, are being increasingly explored and used. 

%\begin{figure}
%\centering
%\includegraphics[scale=0.7]{figures/san.png}
%\caption{Storage Area Network. \alexn{it this your picture, or taken from somewhere else. Note that you cannot copy pictures from the web. Also, please remove references to vendors (such as Brockade).}}
%\label{fig:san}
%\end{figure}



%\begin{figure}
%\centering
%\includegraphics[scale=0.7]{figures/nas.png}
%\caption{Network Attached Storage}
%\label{fig:nas}
%\end{figure}
%new addition
\section{Coding for Storage}
\indent
Architectures for storage ensure reliability by coding and distributing data across disks. Different schemes provide a different balance between reliability, availability, performance and storage capacity. For example, erasure codes transform a block of data into a longer block, such that the original data can be regenerated from a subset of the symbols in the final block. Specifically, say that each data unit such as a file is divided into $k$ symbols. The erasure code generates $n-k$ symbols such that any $k$ of $n$ resulting symbols is sufficient to restore the data.
 

Regenerative codes are a category of codes, specially designed for storage, which address the reconstruction of lost data. This has special applications in distributed storage systems where there is a need to minimize the amount of bandwidth required to restore data redundancy after failure. An $(n,k)$ Minimum Distance Separable (MDS) Regenerating Code can tolerate the failure of any $n-k$ storage nodes. The goal of regeneration codes is to  minimize the amount of data required to be downloaded during a node repair to a theoretical minimum. Thus, these codes improve system performance by minimizing the network resources consumed during the repair process. 

 Despite its relatively young age, the area of regenerative coding for storage is well-studied, with a variety of coding schemes available, as surveyed by Dimakis et al. \cite{dimakis2011survey}. However, most studies assume that an underlying network has a mesh topology, with all coding done at end nodes. Hence, there is an opportunity to improve the performance of regenerative codes in NAS systems by taking advantages of their specific properties (such as the fact that these systems typically use a ring topology). Furthermore, the performance of regenerative codes can be further improved by enabling coding capabilities at network switches. 



\section{Motivation}

\indent 
Conventional architectures for Network Attached Storage systems consist of separate network switches and storage servers. Storage servers are tasked exclusively with functionalities such as %\alex{striping and} 
coding and striping while network switches are tasked with functionalities related to packet processing. This design can be significantly modified by using Software Defined Networks, leading to separation of control and forwarding functions. Such an approach has various potential benefits, chiefly offering greater flexibility, enabling innovation, and reducing costs due to the use of generic SDN network hardware.

%\alexn{this should be separate paragraph since modification of OpenFlow is one of your contributions.}
 Design of SDN-enabled NAS networks would require modifications to existing SDN protocols. This is because there are no solutions in the SDN domain to address storage-related problems. Since there is a lack of literature exploring this approach and an exploration of this design space could be rewarding, we undertake the task of producing a feasible design.

We have a number of choices for designing with SDN. Chiefly, we have to decide on an SDN standard which will be suitable. Of the choices available, OpenFlow \cite{mckeown2008openflow} is an option which has particularly gained traction in the SDN community. % \annote[alex]{should be suitable for our purposes}{it looks like OF is suitable to our purposes because if its popularity, but it is not.}, given its popularity. 
OpenFlow (OF) is a protocol designed for use in Software Defined Networks, for communication between a controller and an OpenFlow-enabled switch. OpenFlow also provides switch abstractions. 
%\remove[alex]{It defines messages for configuring the network.} 
This protocol allows one to easily deploy innovative routing and switching protocols in the network. It also enables the possibility of having applications suited to end use. Accordingly, in our reference architecture, we use OpenFlow as the underlying SDN protocol. However, our methods are not limited to OpenFlow and can be applied to other SDN protocols with minimum modifications.


A successful implementation of a storage network should be able to support standard functions, namely, \textit{read}, \textit{write} and retrieval of metadata, as well as have a provision for timeout. Trivial File Transfer Protocol~\cite{tftp} is a file transfer protocol, implemented over the User Datagram Protocol (UDP), notable for its simplicity. TFTP only reads and writes files from or to a remote server and lacks more sophisticated functionality. It is light and easy to implement and is suitable for experimental purposes. However, this simplicity lends itself to ease of experimentation and enables us to focus on the key features of a NAS system. Accordingly, we adopt TFTP as a file access protocol in our reference architecture. It is important to note that our approach can be used for constructing a reference architecture that uses any other file access protocol. 

%\alexn{it is not clear why you are talking about TFTP here. You can mention that you are using TFTP to create a reference architecture and you exploit its simplicity to your advantage.}

%The lack of research in 

\begin{comment}
%\setlength{\belowcaptionskip}{-10pt}
 
\begin{figure}[H]
\centering
\includegraphics[scale=.6]{figures/components.eps}
\caption{Major Components of a Network Protocol}
\label{fig:components}
\end{figure}

\setlength{\belowcaptionskip}{0pt}
\end{comment}
\begin{comment}
It is challenging to have a conformant and efficient implementation, especially for protocols with complex message structures. As shown in Figure~\ref{fig:mistakes}, mistakes and vulnerabilities exist in the implementations of some of the most widely used protocols by mature commercial companies and open source projects \cite{wripe}. There are many open questions related to the implementation of the message layer of a network protocol, such as OpenFlow. The questions can be classified as one of the two major categories: \emph{conformance} or \emph{performance}. Some questions about conformance include: how do we know our implementation is being conformant to the protocol specifications? How do we design a verification process for the message layer that can be executed in a relatively short amount of time but yet still have a good coverage on potential vulnerabilities? How do we make the verification results can be used directly to eliminate those vulnerabilities? On the other hand, some questions regarding performance include: how do we characterize the performance of a message layer implementation? What are some major design choices and how do those choices affect safety and performance? 
\end{comment}

\begin{comment}
\setlength{\belowcaptionskip}{-10pt}

\begin{figure}[H]
\centering
\includegraphics[scale=1]{figures/mistakes.pdf}
\caption{Sample Message Layer Vulnerabilities in Existing Implementations.}
\label{fig:mistakes}
\end{figure}

\setlength{\belowcaptionskip}{0pt}
\end{comment}

%\alexn{you need to focus on your contribution. In general, the word ``explore'' is more suitable for proposals rather than technical reports. Since you have completed your research, you should talk about specific results you were able to obtain.}
The goal of this thesis is to design an efficient SDN-based NAS architecture and to compare its efficiency relative to more conventional designs. There are two major objectives for this thesis. The first is to create a design using SDN which would support coding and striping functions. The second objective is to measure the performance of this design on relevant parameters. With a design fulfilling minimal levels of flexibility and efficiency, this work contributes to an understanding of the design trade-offs involved and presents a systematic and disciplined approach for design and implementation of storage networks using SDN.


\section{OpenFlow}

\indent 
Software Defined Networks is an approach to networking which allows abstraction of lower level network services by decoupling the data and control plane. This leads to simplification of network management and allows a logically central controller to determine the behavior of the network elements (such as forwarding operations and packet discards). %Figure \ref{fig:sdnoverview} provides an overview of the SDN approach.
\begin{comment}
\setlength{\belowcaptionskip}{-10pt}

\begin{figure}
\centering
\includegraphics[scale=1.0]{figures/topo.png}
\caption{SDN Overview}
\label{fig:sdnoverview}
\end{figure}
\end{comment}
OpenFlow \cite{ofspec} is an SDN protocol that operates over TCP/TLS on the application layer. It defines a set of messages for controllers to configure switch states and carry out desired operations to modify traffic in the swithc, as shown in Figure \ref{fig:ofoverview}. The protocol separates the control plane away from the networking devices in order to achieve a more centralized control on an otherwise distributed network. It achieves this through manipulation of flow tables on the switch through a variety of data structures and messages. There have been a total of 8 versions of the protocol defined by Open Networking Foundation, which acts as the standards development organization for OpenFlow SDN, with version 1.4 being the latest iteration. 

\setlength{\belowcaptionskip}{-10pt}

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{figures/openflow.png}
\caption{OpenFlow Controller and Switch}
\label{fig:ofoverview}
\end{figure}

The switch architecture is well-defined, with a dataplane which is traversed by packets, and a switch agent to interact with the controller. An overview of this architecture is given in Figure \ref{fig:switchanatomy}.
\setlength{\belowcaptionskip}{-10pt}

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{figures/switch_anatomy.png}
\caption{Switch Architecture and Relationship with Controller}
\label{fig:switchanatomy}
\end{figure}



The data plane is a prime component of the architecture of the switch. It refers to the ports, flow tables, group tables, groups, flows, flow classifiers, instructions and actions \cite{flowgrammable}, as shown in Figure \ref{fig:datamodel}. Ports are the entry and exit points for packets, into and out of the switch. These packets are matched to flows, an abstraction used in OpenFlow, using classifiers. Flow tables map these flows to corresponding sets of actions. Additionally, flows may be aggregated into groups to provide similar treatment for packets belonging to different flows. Group tables keep track of the composition of groups and actions specific to each. 

\setlength{\belowcaptionskip}{-10pt}

\begin{figure}[H]
\centering
\includegraphics[scale=0.7]{figures/tinyNBI.png}
\caption{Generalized OpenFlow Dataplane}
\label{fig:datamodel}
\end{figure}
\setlength{\belowcaptionskip}{0pt}

All packets undergo the same process as they traverse the switch data plane. A particular flow in the flow table is selected, using a key constructed from information extracted from the packet and its metadata. Subsequently, the matched action set can drop, mutate, queue, forward, or direct that packet to a new flow table, as referred to in Figure \ref{fig:dataplanelifecycle}.
\setlength{\belowcaptionskip}{-10pt}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{figures/packet_lifecycle.png}
\caption{Dataplane Packet LifeCycle}
\label{fig:dataplanelifecycle}
\end{figure}
\setlength{\belowcaptionskip}{0pt}

OpenFlow packet signatures are contained in a message structure called Match, which is then used for classification, as shown in Figure \ref{fig:matchtable}. Packets are generally classified into flows based on their destination/source MAC, IP and port, among other packet information. For our purposes, we will need to use further information to help classify the relevant packets, which may be achieved by using match extensions. 

\setlength{\belowcaptionskip}{-10pt}

\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{figures/matchtable.png}
\caption{Illustration of Matching on Packet Signature in OpenFlow}
\label{fig:matchtable}
\end{figure}

\setlength{\belowcaptionskip}{0pt}

%\begin{figure}
%\centering
%\includegraphics[scale=.8]{figures/flow_mod_1_0.png}
%\caption{Message Structure for Flow\_mod in OpenFlow 1.0}
%\label{fig:flowmod}
%\end{figure}
%



OpenFlow \emph{Actions} specify the policies on the packets matched to corresponding flow entries. These include forwarding the packet to a specific port (type \emph{Output}) and inserting the packet into a particular queue in a packet (type \emph{Enqueue}). Several policies can be applied on the same flow by attaching a vector of \emph{Actions} with various types in the end of flow modification (\emph{FlowMod}) messages. \emph{Actions} have dependencies and can be layered in a stack as shown in Figures \ref{fig:actionvertical} and \ref{fig:actionstack}. For our purposes, we may need to extend the actions to better serve our application.
%\begin{comment}
\begin{figure}[!h]
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
	\includegraphics[scale=0.7]{figures/action_dependency_1_0_vertical.png}
	\caption{Action Dependencies}
	\label{fig:actionvertical}
    \end{subfigure}
   
   % \hfill
    \begin{subfigure}[b]{0.3\textwidth}
       \centering
\includegraphics[scale=0.7]{figures/action_stack_1_0.png}
\caption{Action Stack}
\label{fig:actionstack}
    \end{subfigure}
    \caption{Action Dependencies and Stack}
    \label{fig:action}
\end{figure}
\setlength{\belowcaptionskip}{-10pt}
\begin{comment}
\begin{figure}
\centering
\includegraphics[scale=1]{figures/action_dependency_1_0_vertical.png}
\caption{Action Dependencies}
\label{fig:actionvertical}
\end{figure}

\setlength{\belowcaptionskip}{-10pt}

\begin{figure}
\centering
\includegraphics[scale=1]{figures/action_stack_1_0.png}
\caption{Action Stack}
\label{fig:actionstack}
\end{figure}
%\end{comment}


\emph{PacketIn} is a message type issued by the switch to the controller. Its main function is to query the controller for the actions for an unknown flow that does not have an entry in the switch flow table, as shown in Figure \ref{fig:packetin}.

%\begin{comment}
\begin{figure}[!h]
\centering
\includegraphics[scale=0.8]{figures/packetin.png}
\caption{PacketIn Message}
\label{fig:packetin}
\end{figure}

\setlength{\belowcaptionskip}{0pt}
%\end{comment}
\emph{FlowMod} is a message type sent from an OpenFlow controller to the switch in order to modify its flow table, as shown in Figure \ref{fig:flowmod}. It consists of a \emph{Match} to classify the flows and a vector of \emph{Actions} to define the policies on these flows. From version 1.1.0 onwards, \emph{FlowMod} carries the \emph{Instruction} structure, which carries an \emph{Actions} list, to modify the \emph{Action} set, for that \emph{Match}.
\begin{comment}
\setlength{\belowcaptionskip}{-10pt}

\begin{figure}
\centering
\includegraphics[scale=1]{figures/flowmod.png}
\caption{FlowMod Message}
\label{fig:flowmod}
\end{figure}

\setlength{\belowcaptionskip}{0pt}
\end{comment}


\begin{figure}[!h]
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
       \centering
\includegraphics[scale=0.8]{figures/flowmod.png}
\caption{FlowMod Message}
\label{fig:flowmod}
    \end{subfigure}
   
   % \hfill
    \begin{subfigure}[b]{0.3\textwidth}
      \centering
\includegraphics[scale=0.55]{figures/group_mod.png}
\caption{GroupMod Message}
\label{fig:groupmod}
    \end{subfigure}
    \caption{Switch Tables' Modification Messages}
    \label{fig:messagetable}
\end{figure}
\setlength{\belowcaptionskip}{-10pt}
\emph{GroupMod} is a message type sent from an OpenFlow controller to the switch in order to modify its group table, as can be seen in Figure \ref{fig:groupmod}. This message was introduced in Version 1.1. It has a bucket which consists of an action set which follows the rules in \emph{FlowMod}.  
\begin{comment}
\setlength{\belowcaptionskip}{-10pt}

\begin{figure}[h]
\centering
\includegraphics[scale=0.6]{figures/group_mod.png}
\caption{GroupMod Message}
\label{fig:groupmod}
\end{figure}
\end{comment}
The controller has applications, which can be programmed to modify network behavior according to the usage requirements of the network. Figure~\ref{fig:seqevents} shows the usual order of messages between the applications and the controller.

\setlength{\belowcaptionskip}{-10pt}

\begin{figure}[h]
\centering
\includegraphics[scale=0.6]{figures/app_events.png}
\caption{Sequence of Messages between Controller and Applications}
\label{fig:seqevents}
\end{figure}

\begin{comment}
\section{Topology}

A simple SDN network can be designed, using minimal devices such that it can be used to show both coding and regeneration. Such a network   [\ref{fig:topology}] can be designed with an OpenFlow Controller and OpenFlow-enabled switches. The topology we design consists of a ring network of five switches with a central controller. The central controller would have an application customizing the network behavior for our storage purposes, depending on our final design. The switches may have additional functionality, as compared to standard OpenFlow switches, depending on our design , in order to provide desired results. 

\begin{figure}
\centering
\includegraphics[scale=0.5]{figures/topology.jpeg}
\caption{System Topology}
\label{fig:topology}
\end{figure}
\setlength{\belowcaptionskip}{0pt}

Such a topology would potentially allow us to obtain three advantages , namely, to leverage SDN to minimise network traffic ,optimally route the traffic to avoid network congestion and maintain metadata about the network and file locations at a central location, preferably at the controller application itself. By keeping spare disks for use at some of the internal servers, we may also be able to simulate disk failure and rebuild scenarios by rebuilding onto a fresh disk from one about to fail.  

\end{comment}


\section{Trivial File Transfer Protocol}

TFTP suits the purposes of our experimentation as it is a simple protocol, built on top of UDP. It is used to move files between machines on different networks. It is small and easy to implement and lacks most of the features of a regular file transfer protocol. However, it fulfills certain basic requirements expected of a file transfer protocol and is thus, ideally suited for our experimentation. Standard exchanges which we are concerned with are File Read, as shown in Figure [\ref{fig:tftpread}], and File Write, as shown in Figure [\ref{fig:tftpwrite}]. 

\begin{figure}
\centering
\includegraphics[scale=0.5]{figures/TFTPReadWithoutOF.png}
\caption{TFTP Read Sequence}
\label{fig:tftpread}
\end{figure}
\setlength{\belowcaptionskip}{0pt}

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{figures/TFTPWriteWithoutOF.png}
\caption{TFTP Write Sequence}
\label{fig:tftpwrite}
\end{figure}
\setlength{\belowcaptionskip}{0pt}

TFTP has certain basic features, specifically, the protocol supports five kinds of packets, each of which has a separate opcode, listed in the table [\ref{tab:opcodes}]. The first packet of the transfer is sent to port 69 of the server from an ephemeral port of the client. The corresponding response to first packet is sent from an ephemeral port, which handles all subsequent packets for that particular transaction. Hence, on completion of the first packet pair, both parties must make note of the corresponding ports and direct future packets to them for the duration of that transfer. 

\begin{table}[h]
\centering
\caption{Opcode vs. Packet Types for TFTP.}
\label{tab:opcodes}
\begin{tabular}{|c|c|}
\hline
Opcode &  Packet/Operation Types\\
\hline
1 & Read Request (RRQ)\\
\hline
2 & Write Request (WRQ)\\
\hline
3 & Data (DATA)\\
\hline
4 & Acknowledgment (ACK)\\
\hline
5 & Error (ERROR)\\
\hline
\end{tabular}
\end{table}

Another feature of the protocol is that acknowledgement packets from the client notify the server of correct receipt of previously sent packet and prevent retransmissions. Failure to receive the ACK within a certain timeout value causes retransmission. The end of a transfer is marked by a DATA packet that contains between 0 and 511 bytes of data. This packet is acknowledged by an ACK packet like all other DATA packets and the host acknowledging the final DATA packet may terminate its side of the connection on sending the final ACK.  However, it is encouraged that the host sending the final ACK wait for a while before terminating, in order to retransmit the final ACK if it has been lost.


\section{Related Works}

SDN has generated a lot of interest from the networking community, and consequently, there has been a plethora of research regarding its capabilities and applications. Nunes et al. \cite{nunes2014survey} provide an overview of this technology and discuss the newer horizons opened up by this, as well as compare it to older technologies. It is notable that this may be used to solve practical problems which may not have been possible with older technologies, as well as have applications which would be more useful than those on conventional networks. 

There has not been much exploration of NAS design with SDN space, to the best of our knowledge. Most published literature in storage domain tends to assume non-SDN networks and thereby focus more on maximizing the gains within those constraints. However, Nemeth et al. \cite{nemeth2012towards}, discuss potentials with OpenFlow architectures and acknowledges coding performed in network switches as being one promising direction of research. This work discusses case studies where this architecture can be beneficial and is a pioneering work in this domain. The authors discuss using Bloom Filters, and Network Coding, and addition of new actions to OpenFlow to enable these novel actions. However, the work only tangentially broaches the topic and a detailed approach to practical implementation focussed on this problem is lacking.

There has been a lot of interest in the field of regenerative coding for storage networks. Dimakis et al. \cite{dimakis2011survey} provide a comprehensive overview of this domain. However, considerations for coding on NAS are notably absent, and this presents an opportunity for us to expand the applications of this into NAS. We undertake a study of suitability and advantages of such schemes on NAS, with coding functionality at switches.   



